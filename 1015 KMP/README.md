- 时间限制:1000ms
- 单点时限:1000ms
- 内存限制:256MB

## 描述

故事背景略

下文约定：

- 原串：`o`，长为 `n`
- 模式串：`p`，长为 `m`
- 模式串的NEXT数组：`k`

### 提示一：KMP的思路

注：原文下标起始为1，且是双闭区间，非常诡异，这里改写成符合 Python 习惯的0起始并且左闭右开区间。

当依序比较到 `o[i - 1] == p[j - 1]` 但 `o[i] != p[j]` 时，已知 `o[i - j:i] == p[0:j]`，

如果存在一个长度 `k[j]` 使得 `p[0:k[j]] == p[j - k[j]:j]` ，此时将 `p[k[j]]` 同 `o[i]` 对齐，则可知 `p[0:k[j]] == o[i - k[j]:i]` ，此前部分都一样，无须重新比较，就可以继续比较 `p[k[j]]` 和 `o[i]` 了。

### 提示二：NEXT数组的使用

对齐操作： `j = k[j]`

当 `j == -1` 时，意味着本节没有匹配，令 `i += 1, j += 1`

当 `j == m` 时，说明产生一个匹配。

### 提示三：如何求解NEXT数组

原文讲的并不清楚，推荐参考这两篇：

- [字符串匹配的KMP算法](http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html)
- [（原创）详解KMP算法](http://www.cnblogs.com/yjiyjige/p/3263858.html)

## 输入

第一行一个整数N，表示测试数据组数。

接下来的N*2行，每两行表示一个测试数据。在每一个测试数据中，第一行为模式串，由不超过10^4个大写字母组成，第二行为原串，由不超过10^6个大写字母组成。

其中N<=20

## 输出

对于每一个测试数据，按照它们在输入中出现的顺序输出一行Ans，表示模式串在原串中出现的次数。

### 样例输入

```
5
HA
HAHAHA
WQN
WQN
ADA
ADADADA
BABABB
BABABABABABABABABB
DAD
ADDAADAADDAAADAAD
```

### 样例输出

```
3
1
3
1
0
```